# NEAT-Columns
Using Neuroevolution to play Columns

The code contained herein allows for the development of an autonomous agent tasked with playing the 1990 16-bit video game classic [Columns](https://store.steampowered.com/app/34285/Columns/), available on Steam for purchase. (*Please note that I have no financial interest in Steam; I merely include the link as the only place known to me to legally acquire the ROM file*).  The game is emulated in [openAI](https://openai.com/)'s [Gym Retro](https://retro.readthedocs.io/en/latest/index.html#) library and the neuroevolution is handled by [NEAT-python](https://neat-python.readthedocs.io/en/latest/#).  A bit of [OpenCV](https://opencv.org/) is used to process the game's video output and most of the math is handled by NumPy and SciPy's ndimage.measurements library to maximize speed via vectorizaton. 

Each frame of the game is rendered in in the gym-retro environment. Depending on the model used, each frame of the game window may be reduced to a simplified representation of the game board and that game state is then fed into the NEAT-Python neural net (these implementations use a [recurrent neural network](https://en.wikipedia.org/wiki/Recurrent_neural_network) architecture) and the ouput of the neural network is then translated, either directly or indirectly, into one or more simulated button presses on the virtual controller to move the game piece in play.  

As the game proceeds, the fitness of the network is evaluated based on the results it generates.  There are two major contributors to the fitness function: those portions that are derived from a scoring event and those portions that come from "nudges" toward better gameplay.  Scoring events are scaled (or not) to encourage the agent/RNN under evaluation to favor certain behaviors.  The game awards the player a single point for pressing the "down" key to hasten the falling of the game piece in play into final position.  Since this behavior can largely be automated with little thought for an artificial player, this fitness bonus is not scaled, i.e., it recieves a 1x multiplier.  Making matches increases the player's score by 10 x the number of blocks matched x (the level + 1).  This is the action we want to reward most, and so we scale it by a factor of 500.  As levels increase with longer game play periods, this makes scoring matches *extremely* rewarding. A third scoring event involves a wild-card block, which destroys all blocks of the color on which it lands. This is counted as any other match event would.  However, if the wild-card block falls to the bottom of the game board without landing on top of any other gem, the player scores a flat 10,000 points.  This is very desireable in the early game, but becomes much less so at higher levels.  The scaling of this behavior is also encouraged, but is only given a x5 multiplier. 

Code is provided in [Jupyter Notebook](https://jupyter.org/) format (.ipynb)
